package name.jchein.portfolio.micros.resolution.registry.service

import io.eventuate.AggregateRepository
import io.eventuate.EntityWithIdAndVersion
import io.eventuate.SaveOptions
import java.util.UUID
import java.util.concurrent.CompletableFuture
import javax.validation.constraints.NotNull
import javax.validation.constraints.Pattern
import javax.validation.executable.ExecutableType
import javax.validation.executable.ValidateOnExecution
import name.jchein.common.validation.constraints.ProcessId
import name.jchein.common.validation.constraints.ResolvesToIP
import name.jchein.common.validation.constraints.UUIDString
import name.jchein.demo.bstocksolutions.manifest.ingest.task.aggregate.AssignWorkerProcess
import name.jchein.demo.bstocksolutions.manifest.ingest.task.aggregate.BeginManifestImportActivity
import name.jchein.demo.bstocksolutions.manifest.ingest.task.aggregate.ManifestImportActivity
import name.jchein.demo.bstocksolutions.manifest.ingest.task.aggregate.ManifestImportCommand
import name.jchein.demo.bstocksolutions.manifest.ingest.task.aggregate.ReleaseWorkerProcess
import name.jchein.demo.bstocksolutions.manifest.ingest.task.value.WorkerLocation
import org.hibernate.validator.constraints.Email
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Component

import static extension java.util.Optional.of

@Component
@ValidateOnExecution(type=ExecutableType.ALL)
class ManifestActivityService
{
	private final AggregateRepository<ManifestImportActivity, ManifestImportCommand> taskRepository;

	@Autowired
	new(AggregateRepository<ManifestImportActivity, ManifestImportCommand> taskRepository)
	{
		this.taskRepository = taskRepository;
	}

	private def toSaveOptions(UUID activityId)
	{
		return new SaveOptions().withId(activityId.toString()).of()
	}

	def CompletableFuture<EntityWithIdAndVersion<ManifestImportActivity>> beginImportActivity(
		@NotNull UUID activityId,
		@Email @NotNull String email,
		@NotNull @UUIDString String locationId,
		@NotNull @UUIDString String marketplaceId
	)
	{
		return this.taskRepository.save(
			BeginManifestImportActivity.build [
				it.email = email
				it.locationId = locationId
				it.marketplaceId = marketplaceId
			],
			activityId.toSaveOptions()
		)
	}

	def CompletableFuture<EntityWithIdAndVersion<ManifestImportActivity>> assignWorkerProcess(
		@NotNull UUID activityId,
		@NotNull UUID workerId,
		@NotNull @ResolvesToIP String nodeAddress,
		@ProcessId int processId,
		@NotNull @Pattern(regexp="/([-_.~a-zA-Z0-9]*\\/)*[-_.~a-zA-Z0-9]*/") String fileCachePath
	)
	{
		return this.taskRepository.update(
			activityId.toString(),
			AssignWorkerProcess.build [
				it.workerId = workerId.toString()
				it.locator = WorkerLocation.build [
					it.nodeAddress = nodeAddress
					it.processId = processId
					it.fileCachePath = fileCachePath
				]
			]
		)
	}

	def CompletableFuture<EntityWithIdAndVersion<ManifestImportActivity>> releaseWorkerProcess(
		@NotNull UUID activityId, @NotNull UUID workerId
	)
	{
		return this.taskRepository.update(
			activityId.toString(),
			ReleaseWorkerProcess.build[it.workerId = workerId.toString()]
		)
	}
}
